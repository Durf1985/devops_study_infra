# Conspect

## Данные сетевых настроек в среде обучения

ip bob - 172.16.238.15
ip devapp01 - x.x.x.10
ip devdb - x.x.x.11

## Список команд RPM - не учитывает зависимостей

install rpm -ivh telnet.rpm
uninstal -e
upgrade -Uvh
query -q
verifyng -Vf "path to file"
rpm -qa | grep "package name" - узнать точное имя пакета установленого в системе

---

## Установка пакетов Yum

yum install httpd - установка пакетов
yum repolist - показывает все репозитории добавленные в систему
yum provides scp - кто предоставляет команду scp
yum remove httpd - удаление пакета
yum update "package name" - обновление конкретного пакета
yum update - обновление всех пакетов в системе, если требуется установить дополнительно зависимые пакеты, то это будет сделано

DPKG - не учитывает зависимостей так же как и rpm
dpkg -i "package name.deb" - установка пакета
dpkg -r "package name.deb" - удаление
dpkg -l "package name" - список пакетов
dpkg -s "package name" - статус пакета, если он установлен
dpkg -p "path to file" - отобразить детальную информацию (Verifying)

---

apt and apt-get - не зависят друг от друга, разные системы
apt -более user friendly
etc/apt/sources.list

apt install gimp - установка пакета
apt remove "package name" - удалить
apt search <-||-> - поиск пакета в репозитории
apt list | grep <-||-> - посмотреть список всех доступных пакетов
apt-get install gimp
apt update - обновить репозиторий, скачать информацию о всех доступных источниках,
рекомендуется запускать после установки ОС или после добавления нового источника
apt upgrade установить обновления всех пакетов, которые есть в ОС из всех настроеных источников
apt edit-sources - обновить репозитории
чтобы добавить больше репозиториев редактируй source.list

du -sk <имя файла> - показать размер файла в килобайтах
du -sh <имя файла> - показать размер в мегабайтах
ls -lh - списком показать размер

## Tar Tape archive - архиватор

tar
-cf <\*.rar> "file1" "file2"..."file N" заархивировать указанные файлы
-c - создать архив
-f присвоить свое название архиву
-tf - посмотреть содержимое архива
-xf - распаковать архив
-zcf - сжать архив
Компрессоры, добавляют расширение в конец имени файла bz2, gz, xz
bzip2 <имя файла>
gzip
xz
Декомпрессоры
bunzip2
gunzip
unxz
Просмотр без декомпрессии
zcat (gzip), bzcat, xzcat

## Поиск файлов и директорий

locate <паттерн (имя.расширение)> найдет все пути которые соответствуют паттерну, зависит от mlocate.db,
если ОС установлена недавно или файл только что создан, то эта команда
может не найти, потому что DB не обновилось
updatedb - ручное обновление DB, запускается с правами root user
find /home/userName -name <fileName.extension> - поиск в конкретной папки и вложениях

## Поиск в файлах

grep <паттерн поиска> <имя файла в котором поиск> поиск регистрозависимый, ищет строку в которой есть упоминание,
если вы искали exam, то будут выведены строки содержащие слова
examples, exampl or etc.
-w - искать точное соответствие, если ищите exam, то слова examples exampl... не будут отображаться
-i -||- - игнорировать регистр
-r "паттерн поиска" /home/userName - найти все упоминания во всех файлах в текущей папке и подпапках
-v "паттерн поиска" <имя файла> - найти все строки где нет искомого паттерна
-vw - найти все строки где нет точных совпадений с паттерном.
-A1 - показать 1 строку после найденного паттерна
-B1 - показать 1 строку перед найденным паттерном
-A1 -B1 - показать 1 строку после и 1 строку до паттерна

## IO redirection

"some command" - standart input like cat sample.txt

This is the file contents - sусtandart output
echo $SHELL > shell.txt - перезаписать вывод в файл, с удалением предыдущего содержимого. >> - дописать в файл без удаления содержимого

No such file or directory - Standart error
echo $SHELL 2> shell.txt - цифра 2 говорит о том, что в этот файл нужно внести вывод ошибки, если такая будет
файл будет перезаписан
2>> - двойная стрелка допишет, а не затрет
cat misiзнng_file 2> /dev/null - перенаправить в bit bucket, ведро в котором хранится все ненужное, например ошибка,
которую мы не хотим видеть в выводе

## Command-line pipes каналы командной строки

последовательность команд осуществляется с помощью символа "|" like "command1 | command2"
grep Hello sample.txt | less - показать только строку содержащую паттерн Hello

echo $SHELL | tee shell.txt - tee позволяет перенаправить вывод в файл, но при этом выводит его на экран перед
тем, как переписать конечный файл
| tee -a shell.txt - позволяет дописать конечный файл

## VI editors

vi <путь к файлу/имя файла> - открыть файл в VI editors - command mode копипаста+удаление линий или слов
Разберись по мере необходимости

---

добавить в /etc/hosts xxx.xxx.xxx.xxx <короткое имя>
тогда можно делать ping <короткое имя>
/etc/resov.conf - файл в котором хранится адрес DNS сервера, каждый раз когда ваш хост сталкивается с неизвестным
адресом, то он обращается на DNS сервер где получает обновление.
Если короткое имя на локальной машине совпадает
с именем на DNS сервере, но отличается IP адресс, то будет выбран локальный вариант. Этот порядок может быть изменен
/etc/nsswitch.conf - порядок обращений можно изменить в этом файле
Если на локальном DNS сервере нет имени, то можно сделать проброс на другой DNS сервер, например на 8.8.8.8 (google)
тогда можно будет пинговать даже адреса не указанные в hosts локальной машины или локального DNS сервера
Forward All to 8.8.8.8
apps.google.com - например я пингую этот адрес.

1. Сначала будет просмотрен хост на моем локальном компьютере
2. Далее запрос будет перенаправлен на сервер Ростелекома
3. далее если сервер ростелекома не знает этого имени, то отправит дальше по своему списку
4. когда список закончится, то отправится на сервер .com
5. сервер .com redirect to .google
6. server .google to apps
   Чтобы каждый раз не проходить эту цепочку DNS сервер ростелекома может временно запомнить этот IP
   apps.google.com => 216.58.221.78

ssh "target host" - установить соединение с целевым узлом

ip link - проверить состояние сетевого интерфейса на локальном компьютере - up or down
nslookup "target hostname" Проверяем можем ли мы преобразовать имя хоста в IP с помщью DNS сервера
ping "target host" пингуем нашу цель, не всегда возможно, потому что настройки сети могут не позволять это делать
traceroute "target ip or hostname" - проверяем количество устройств между локальной машиной и целевым адресом

---

## Security

/etc/passwd - информация о пользователях
/etc/group - хранит информацию о группе пользователей

## Способ хранения информации о пользователе

username - имя пользователя
UID- идентификатор пользователя привязанный к имени пользователя
GID - Идентификатор группы, к которой принадлежит пользователь. Если никаких групп не создано, то будет использован UID
Аккаунт пользователя так же содержит информацию о домашней директории пользователя (прим: /home/alex ) и оболочке по умолчанию (/bin/shell)

Superuser Account - UID 0 имеет не ограниченный доступ к системе root
System Account UID для системных акаунтов обычно от 0 до 100 или между 500 и 1000 у них чаще всего нет собственной домашней директории, но если есть
то создается не в папке /home sshd и mail user примеры системных аккаунтов
Service Account - nginx, mercury. Т.е. сервис nginx использует аккаунт nginx

id - команда дающая информацию о пользователе (UID,GID, и другие группы, к которым он принадлежит)
who - посмотреть список пользователь, которые залогинились в систему в данный момент
last показывает историю логинов
sudo - выполнять от имени root используя свой личный пароль. Эти разрешения конфигурируются в /etc/sudoers
visudo позволит редактировать этот файл
su - сменить пользователя switch user may be. не рекомендуется использовать, потому что нужен пароль пользователя на которого вы переключаетесь

         конфигурация sudoers файла

"# комментарий описывающий права пользователя"

1. user or group - синтаксис bob, %sudo - % если используется для группы
    sample: bob or %admin ALL= (ALL) ALL
2. Hosts - localhost, ALL указывает конкретные хосты на которых пользователь может получить повышение прав доступа - по умолчанию ALL
    обычно это локальный хост
3. User (в скобках) подразумевает пользователей и группы All подразумевает всех пользователей, не только root
4. Command - если указанно All то пользователь может выполнять любые команды без ограничений, либо ограничено
например bob localhost=/usr/bin/shutdown -r now - т.е. пользователь боб может использовать команду судо только для перезагрузки конкретного хоста

## Управление пользователями

useradd "username" - позволяет администратору создать нового локального пользователя его UID and GID можно посмотреть в /etc/passwd
так же будет создана домашняя папка /home/username и установлена оболочка по умолчанию /bin/sh
/etc/shadow (не знаю что за файл)
passwd "username" - установить пароль для "username"
обе команды надо выполнять как root
whoami - проверить под каким пользователем
passwd -без аргументов позволяет пользователю сменить пароль для своей учетной записи

useradd -u 1009 (specific UID) -g 1009 (specific GID) -d /home/robert (custom home directory) -s /bin/bash (custom shell) -c "Merc proj" (custom comment) -e (expire date - срок)
-G создать пользователя с множественным участием в группах

userdel
groupadd
groupdel

## Access Control Files

Большинство файлов отвечающих за доступ находится в /etc многие пользователи могут читать эти файлы, но редактировать может только root
Данные файлы невозможно отредактировать с помощью текстового редактора, но возможно отредактировать через набор команд
Файл /etc/passwd - не хранит пароли они хранятся в другом файле
/etc/shadow - имя, пароль в зашифрованном виде, если пусто или звездочка, то пароль никогда не указывался для этого пользователя,
дата последнего изменения, MINAGE - минимальное количество дней, после которых будет разрешено изменить пароль, MAXAGE - максимальное количество дней,
в которые можно не менять пароль Warn - количество дней оставшееся до истечения срока действия пароля inactive - количество дней, когда доступ сохраняется, после
устаревания пароля (если пустое, то значит опция не применяется) Expdate - дата когда пароль становится не актуальным, если поле пустое, значит срок действия пароля бесконечен

/etc/group - хранит информацию о группах - имя группы GID и участников группы

## File permissions

ls -l bash-script.sh
-rwxrwxr-x 1 bob ~

- regular file, может быть d - directory c - тип устройства l - link p -pipe b- block device
-|RWX|rwxr-x - ownerpermission
-rwx|RWX|r-x - group permission
r-x - other user permission
r- read (4) w-write (2) -x execute (1) "-" (0) - no permission
для директорий тот же набор, x - надо уточнить

chmod "permissions" file -установка разрешений

chmod u+rwx "file name" - установка разрешений для owners
chmod ugo+r-x "fn" - установка разрешений для owners groups other - дать права читать забрать право исполнять
chmod o-rwx - забрать все права доступа у other
chmod u+r,g+
if a command line argument is a symbolic link
to a directory, traverse it
chown owner:group file
chown bob:developer test-file - изменить владельца на bob и группу на developer
chown bob test - изменить владельца на bob группу не менять
chgrp groupname filename - изменить группу не меняя владельца.

## SSH & SCP

ssh - позволяет логиниться и исполнять команды на удаленном компьютере
можно делать через 2 способа

1. user+password auth
2. ssh key auth without password

## IPTable

Позволяет разграничивать доступ, т.е. чтобы сервер базы данных не имел доступа в интернет, а только отвечал на запросы сервера приложений.
sudo apt install iptables - установка iptable
sudo iptables -L - позволяет увидеть список правил по умолчанию
Input Chain - сетевой трафик входящий в систему, например чтобы позволить SSH соеднинение мы должны добавить
правило на devapp server (то чем собираемся управлять) чтобы разрешить соединение
Output Chain - управление исходящими запросами, например наш сервер приложений обращается к серверу базы данных
policy ACCEPT - не установлено никаких других правил и разрешены любые запросы
Цепь работает по принципу if esle-if, по принципу если что-то не запрещено, то разрешено. Т.е. если у вас есть разрешение
для 1 адреса или диапазона адресов, но нет запрета для всех остальных, то сервер будет принимать все запросы без исключений
рассмотрим ситуацию ноутбук подключатеся к серверу по SSH
для этого на сервере:
iptables -A INPUT -p tcp -s 172.16.238.187 --dport 22 -j ACCEPT
где
-A - add rule
-p - protocol (tcp in this case)
-s - source IP or range IP
--dport - destination port 22 - for SSH
-j - действие которое необходимо предпринять - accept/drop

- I - вставить правило в начало цепи, а не в конец
- D <INPUT/OUTPUT> "rule number" - удалить правило из цепи под номером n
  iptables -A INPUT -p tcp --dport 22 -j DROP
  Например мы разрешаем серверу приложений делать запросы у базы данных по какому-то конкретному IP и порту.
  На сервере БД не нужно создавать дополнительно правило в OUTPUT для того, чтобы БД вернула ответ серверу приложения
  это будет сделано на IP с которого пришел запрос но на другой порт в диапазоне с 32768 - 60999

         Cronjobs

  Допустим нам надо выполнять такую команду каждый день
  uptime >> /tmp/system-report.txt
  для этого
  crontab -e - запустить команду под пользователем для которого настраивается расписание
  не запускать команду используя sudo иначе расписание будет применено к root пользователю
  если нужно запускать команду каждые 2 секунды то и \*/2
  crontab -l -посмотреть список
  проверить можно 2 способами

1. tail /var/log/syslog - посмотреть логи выполнения команды
2. если в расписании заносится запись в какой-то файл, то проверить файл

## Service management with SYSTEMD

есть скрипт /usr/bin/project_mercury.sh
чтобы запустить его в фоновом режиме нужно определить его как сервис, для этого нам надо создать service nit file
путь к юниту
/etc/systemd/system/project-mercury.service

тело юнита:
[Unit]
Description= Python Django for Project Mercury можно указать описание и ссылку на документацию
Documentation = <http://wiki.caleston-de>
After=postgresql.service - установить зависимость, т.е запустить сервис project_m только после запуска сервиса postgresql
[Service]
ExecStart= /bin/bash(путь к оболочке) /usr/bin/project-mercury.sh(полный путь к скрипту)
User=project_mercury - устанавливает кто выполняет вместо root
Restart=on-failure -как и когда перезагрузить сервис
RestartSec=10 - указать интервал ожидания перед перезапуском службы (в секундах)
[Install]
WantedBy graphical.target - для запуска сервиса во время загрузки ОС (для указания целевого состояния в котором произвести запуск)
systemctl start project-mercury.service - чтобы запустить этот юнит в фоновом режиме

systemctl status project-mercury.service - проверить состояние скрипта
systemctl stop <name.service> - остановить юнит

systemctl deamon-reload -перезапустить демона, чтобы чтобы он увидел изменения внесенные в юнит, а дальше запустить юнит

## Systemd Tools - управление запущенными фоновыми службами

Есть 2 главных команды
systemctl
start docker -запустить сервис докер
stop docker - остановить
restart docker -перезапустить
reload docker -без прерывания исполнения функционала
enable docker -Чтобы включить службу и сделать ее постоянной при перезагрузке
disable docker - выключить службу при загрузке
status - состояние (active/inactive/failed/activating/deactivation)
edit "servicename" --sfull - юниты редактируемые таким образом применяют изменения немедленно без перезагрузки демона
get-default -посмотреть дефолтный целевой уровень или текущий (graphical.target and etc)
set-default multi-user.target
list-units --all -показать все запущенные и пытающиеся запуститься юниты

journalctl- выдать все записи лога от старых до новых
-b - посмотреть логи текущей загрузки
-u UNIT - посмотреть логи конкретного юнита
sample.service: Service lacks both ExecStart= and ExecStop= setting. Refusing

## Storage in Linux

lsblk - посмотреть список устройств
ls-l /dev/directory - делает тоже самое
sda - общее название диска
sda1...n - тип part
sda3 - root
sda2 -backups
sda1 - boot

Major number
1 ram
3 hard disk or cdrom
6 parallel printers
8 scsi disk
minor number для различия физического или логического устройства

sudo f disk -l /dev/sda
primary partition - разделы, которые могут использоваться для загрузки ос
extended partition - разделы, которые не могут быть использованы сами по себе, но могут содержать логические разделы, с ограничением на 4 основных раздела
можно выбрать создание расширенных разделов и нарезать в нем логических разделов
MBR - master boot record - могут быть только 4 primary partitions in MBR
Maximum size per disk = 2 TB
GPT stands for GUID partition table (расшифровывается как) - является более поздней схемой
позволяет создавать больше 4 разделов в отличии от MBR и нет лимита в 2 Тб, если только ОС не требует именно MBR
RHEL - всего 128 разделов на диск

gdisk /dev/sdb (device path) - создание раздела на sdb disk
? после ввода команды выше знак ? выводит все доступные команды
n - создать новый раздел
L - тип раздела можно изменить но рекомендуется Линукс дефолт (8300),
w - записать таблицу разделов создаст /dev/SDB1
sudo fdisk -l /dev/sdb or lsblk чтобы проверить создание раздела

mkfs.ext4 /dev/sdb1 (device path) Создание файловой системы.
после этого можно монтировать
mkdir /mnt/ext4
mount /dev/sdb1 /mnt/ext4
mount | grep /dev/sdb1 - проверить смонтировалась файловая система или нет.
df -hP | grep /dev/sdb1 -либо так

после перезагрузки системы добавить запись в файл /etc/fstab
file system - dev/vdb1 or etc
mount point - директория в которую смонтировано
Type - ext 2-4
Options - RW= read-write, RO=read-only and etc
Dump 0= ignore 1=take backup
pass 0=ignire 1 or 2 = FSCK filesystem check enforced (принудительная проверка файловой системы после краша)

echo "/dev/sdb1 /mnt/ext4 ext4 rw 0 0" >>/etc/fstab

## DAS,NAS&SAN

DAS - Direct Attached Storage - подключается напрямую к ПК которому нужно дополнительное место недостаток в том, что он подключен только к 1 серверу и может использоваться только им
NAS - Network Attached Storage
SAN - Storage Area Network - использует оптоволокно, для обеспечения скорости. Выделяется хостам в качестве LUN (Logical Unit Number)
Lun - набор блоков подготовленый из пула общего хранилища и представленого на сервере как логический диск. Хост видит его как необработанный диск на котором можно создать
разделы и файловую систему FCP - Fiber Channel Protocol

NFS (Filesystem) - работает по принципу - хост - сервер. конфигурируется в /etc/exports определяет какие клиенты должны иметь доступ к директориям на сервере
простейшая конфигурация выглядит как /software/repos "client1 ip" "clientn IP" или диапазон IP или * чтобы не было ограничений
exportfs - после того как файл на сервере будет сконфигурирован нужно его экспортировать
exportfs -a - экспортировать все смонтированные из файла /etc/exports

- o clienIP:filepathonserver(/software/repos)- ручной экспорт
- mount serverip:/software/repos /mnt/software/repos

LVM - Logical volume manager - позволяет объединять группу разделов или физических дисков в объемную группу, которую можно разделять на логические хранилища
apt-get install lvm2
pvcreate /dev/sdb - создание физического объема
vgcreate caleston_vg /dev/sdb - группа под название calwston_vg - создана
pvdisplay
vgdispaly
lvcreate -L 1G -n vol1 caleston_vg - создание логического пространства
-L - линейный тип
1G - 1 гигабайт

lvdisplay
lvs- list volume
mkfs.ext4 /dev/caleston_vg/vol1
mount -t /dev/caleston_vg/vol1 /mnt/vol1
Изменение размера vol1 в состоянии смонтировано

1. vgs проверка есть ли место
2. lvresizq -L +1G -n /dev/caleston_vg/vol1 - увеличится только общий логический объем, но не файловая система созданная в этом объеме
3. resize2fs /dev/caleston_vg/vol1 - подогнать размер файловой системы к размеру логического объема
